---
title: DevOps 06 - Kubernetes basics
layout: post
subtitle: null
date: '2022-02-16 14:30:00'
author: Lanzhou
header-img: img/post-bg-unix-linux.jpg
tags:
- study
- English
- wiki
---
**Research summary:**

- Basic objects
- Basic concepts

### 1. Why?

- **Why we need Kubernetes?**

**Issues related to Container Deployment**

- When one container is not working, how to start a new container automatically to replace the existing container.
- When workload increases, how to scale containers horizontally & automatically.

These issues are **container orchestration issues**.

**Container orchestration tools**

- Docker Swarm
- Mesos
- Kubernetes ...

**Why choose Kubernetes?**

![why k8s](/img/in-post/why-choose-k8s.png)
![k8s market share](/img/in-post/k8s-market-share.png)

### 2. What?
- **What is K8s?**
![what k8s](/img/in-post/what-k8s.png)

- "Kubernetes" → ancient Greek word for "helmsman". → ship wheel logo
- Kubernetes → a group of servers → cluster
    - It can **run specific program in different nodes**, in order to manage containers inside these nodes. The purpose is to automate resource management.

- **What can K8s do?**
- **Kubernetes functions:**
    - Self-healing: restarts containers that fail.(within 1 second)
    - Automatic bin packing:
        - You tell Kubernetes how much CPU and memory (RAM) each container needs. Kubernetes can fit containers onto your nodes to make the best use of your resources.
    - Service discovery: One service can automatically discover the services that it depends on.
        - Service discovery → **a technique for getting traffic from one container to another using the containers direct IP address**
        - Kubernetes can expose a container using the DNS name or using their own IP address.
        - Service discovery takes advantage of the labels and selectors to associate a service with a set of pods.
        - A single pod or a ReplicaSet may be exposed to internal or external clients via services, which associate a set of pods with a specific criterion. Any pod whose labels match the selector defined in the service manifest will automatically be discovered by the service. This architecture provides a flexible, loosely-coupled mechanism for service discovery.
    - Load balancing
        - If traffic to a container is high, Kubernetes is able to load balance and distribute the network traffic so that the deployment is stable.
    - Automated rollouts and rollbacks
        - If the newly released version is not working, can instantly roll back to the previous version.
    - Storage Orchestration
        - Kubernetes allows you to automatically mount a storage system of your choice, such as local storages, public cloud providers, and more.
    - Elastic stretching? Is K8s elastic?


### 3. How?

- **How does K8s work?**
    - Basic Components:
        - A Kubernetes cluster consists of a set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node.
        - A kubernetes cluster is composed of master node(Control Plane) and worker nodes.
        - Master node → Control & Management (Control plane)
            - ApiServer: The only entrypoint for managing resources, accept user commands...
            - Scheduler: Responsible for resource schedule, schedule pods to corresponding nodes following designed strategies. (Focus on using algorithm to calculate & decide who is going to do the job)
            - ControllerManager: Responsible for maintaining the state of the cluster, such as create pos, program deployment arrangements, fault detection, automatic scaling, and rolling updates
            - Etcd: Responsible for storage of the info of resource objects. (e.g. Master asked Node1 to run a job nginx)
        - Worker node → work (data plane, provides a running env for containers)
            - Kubelet: Responsible for container life cycle, control docker to create or destroy containers. （Contact of master, manage docker）
            - KubeProxy: responsible to provide service discovery inside cluster & load balancing. (User can visit app inside container via kube-proxy)
            - Docker: responsible for managing containers
        
        
        - the API which sits in front of services, the worker nodes & the Kubelet process that the nodes run, all together make up the Kubernetes Cluster.
        
        
  #### **How to deploy an nginx app**

    - `minikube start`
    - `kubectl get nodes`
    - `cd Desktop/DevOps/Ex_Files_Learning_Kubernetes_Upd/Exercise\ Files`
    - `cd 03_04`
    - `k get all`
    - `k create -f helloworld.yaml`
    - `k get all`
    - `kubectl expose deployment helloworld --type=NodePort`
    - `k get all`
    - `minikube service helloworld`
    1. To start up minikube, you can type the command `minikube start`.  Once this completes, we get a quick note saying that it's done and kubectl is now configured to use minikube. 
    2. So let's actually take a look to see whether this is up and running. I can do this by running the command `kubectl get nodes`. So I'm going to clear my screen and do a `kubectl get nodes` and in this case, we see we have nodes, it's called minikube in the ready status with roles of master, 30 seconds old because they're just created. 
    3. `cd Desktop/DevOps/Ex_Files_Learning_Kubernetes_Upd/Exercise\ Files` ， `cd 03_04`Next up, We're actually going to run helloworld.yaml because that's going to have our simple Hello World application that we want to run. 
    4. But first up, let's look to see what's in our cluster right now. We just created this, so there shouldn't anything in there. To figure out what's in your cluster, you can run the command `kubectl get all`, returns all resources. There is a service Kubernetes with the cluster-IP. It's been online for about 15 minutes or so. 
    5. Alright, let's go ahead and deploy our application. In order to do that, I'm going to run the command `kubectl create` because I'm going to create a resource minus f, meaning file and then helloworld. And we get a deployment helloWorld was created. 
    6. Once again, if I run `kubectl get all`, I should hopefully see more resources here. And I do, I see the service that was there before, but now we have a pod of helloworld with a grid passed after that. A deployment of helloworld and also a replica set associated with that. The other things to kind of look forward to over here are their ready states. So we noticed that the pod is ready to go, one of one, deployment is ready to go one on one as well. All of these seem to have an age of 11 seconds. So in all accounts, it looks like the deployment is ready to go. 
    7. But how do we actually access this, right? 'Cause this has a little web page that we want to access. How do we go about that? So in order to do that, we need to create the service construct for Kubernetes. And I can expose this deployment as a service. So in order to do that, let's clear my screen. I can run the command `kubectl expose`. And then I'm going to expose the deployment. I need to pass the name, so we call this helloworld earlier and I'm going to expose this as a type of node port. 
    8. And we'll notice here that it says, service/helloworld was exposed. So if I take a look at the cluster again, get all, we notice that we now have two services, the Kubernetes one like we had before, but now helloworld. It's of type NodePort, which is what we declared it as, been online for nine seconds and should be accessible on this specific port. 
    9. One of the nice things about minikube is I can run the `minicube service helloWorld` command. And by service helloworld, it should reference the helloworld service we just created. Once I run this, it actually takes me to the web browser on this specific IP and port. And it brings up our little deployment exposes service, which is our little UI, you can reload this, we see the counter that keeps reloading and one of the neat things I've done here is I can actually copy the container ID, bring this back to the terminal. And if I search for the container ID will notice that it references the pod that we just have, which is great. 
    10. The other thing I want to call out to attention to, we kind of scrolled up a little bit too fast, but when you run minikube service helloworld, we notice we get this little table. It says, the namespace default, the application name, and the URL. **So 192.168.64.2:32124, which is essentially** what we saw over there. So there we have it. We have a deployment up and running. It's exposed as a service. So our simple Hello World app is up and running.
    11. `cat helloworld.yaml` → A little nginx container app
    
    **Nginx service Example**:
    
    1. Firstly, once k8s environment is running, master and worker node would store their info inside etcd database. 
    2. A nginx service installation request would be send to ApiServer inside master node.
    3. ApiServer will use Scheduler component to "think" and determine which node is responsible for service installation task. At the same time. it would read nodes info from etcd, then use algorithm to calculate and choose between different worker nodes and give the result to ApiServer.
    4. ApiServer would use Controller-Manager to arrange a worker node to install nginx service.
    5. Once kubelet receives command, it will notify docker, and let docker to start a nginx pod. (minimum unit in k8s, containers running inside pod)
    6. So nginx service is running successfully now, if user wants to visit nginx, kube-proxy (k8s network proxy) can create proxy of pod, so that outside users can visit nginx service inside the cluster.
    
### Basic Objects
  - NameSpace
      
      - used to isolate pods running environments, logical pods group.
      - *namespaces* provides a mechanism for isolating groups of resources within a single cluster.
  - Pod: Smallest unit in k8s, containers are running in pods, 1 or more containers inside one pod.
      
  - Deployment: pod controller
      
  - Controller: k8s manage pods via controller, like start pod, stop pod, scaling pod numbers etc. (Multiple controllers)
  - Service:  a Service is an abstraction which defines a logical set of Pods; unified entrance, multiple pods link to one service. → load balancing etc. Service is the bridge in between pods and outside.
        
  - Ingress:
      - An API object that manages external access to the services in a cluster, typically HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting.
         
  - Label & Selector: used to characterise pods for example, similar pods have the same label, service map to pods based on label (using selector) (Label is not only for pods!)
      
- Basic Concepts
  - Master: Cluster control node, a cluster has at least one master node.
  - Node: Workload node, master arrange containers to the nodes, worker node is responsible for running the containers.

Useful Resources:
